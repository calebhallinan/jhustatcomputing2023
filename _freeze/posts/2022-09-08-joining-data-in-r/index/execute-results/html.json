{
  "hash": "99ff9a138935856c71740e4d62679c97",
  "result": {
    "markdown": "---\ntitle: \"Joining data in R\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to relational data and join functions in the dplyr R package\"\ndate: 2022-09-08\ndraft: true\ncategories: [module 1, week 2, R, programming, dplyr, here, tidyverse]\n---\n\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1. <https://r4ds.had.co.nz/relational-data.html>\n2. <https://rafalab.github.io/dsbook/joining-tables.html>\n\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n- <https://rdpeng.github.io/Biostat776/lecture-joining-data-in-r-basics.html>\n- <https://r4ds.had.co.nz/relational-data.html>\n- <https://rafalab.github.io/dsbook/joining-tables.html>\n\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n- Be able to define relational data and keys\n- Be able to define the three types of join functions for relational data\n- Be able to implement mutational join functions\n\n:::\n\n# Relational data \n\nData analyses rarely involve only a single table of data. Typically you have many tables of data, and you must combine them to answer the questions that you are interested in. Collectively, multiple tables of data are called **relational data** because it is the relations, not just the individual datasets, that are important.\n\nRelations are always defined between a pair of tables. All other relations are built up from this simple idea: the relations of three or more tables are always a property of the relations between each pair. Sometimes both elements of a pair can be the same table! This is needed if, for example, you have a table of people, and each person has a reference to their parents.\n\nTo work with relational data you need verbs that work with pairs of tables. There are three families of verbs designed to work with relational data:\n\n- [**Mutating joins**](https://r4ds.had.co.nz/relational-data.html#mutating-joins): A mutating join allows you to combine variables from two tables. It first matches observations by their keys, then copies across variables from one table to the other on the right side of the table (similar to `mutate()`). We will discuss a few of these below.\n- [**Filtering joins**](https://r4ds.had.co.nz/relational-data.html#filtering-joins): filtering joins match observations in the same way as mutating joins, but affect the observations, not the variables (i.e. filter observations from one data frame based on whether or not they match an observation in the other). Two types: `semi_join(x, y)` and `anti_join(x, y)`.\n- [**Set operations**](https://r4ds.had.co.nz/relational-data.html#set-operations): treat observations as if they were set elements. Typically used less frequently, but occasionally useful when you want to break a single complex filter into simpler pieces. All these operations work with a complete row, comparing the values of every variable. These expect the x and y inputs to have the same variables, and treat the observations like sets: e.g. `intersect(x, y)`, `union(x, y)`, and `setdiff(x, y)`.\n\n\n### Keys\n\nThe variables used to connect each pair of tables are called **keys**. A key is a variable (or set of variables) that uniquely identifies an observation. In simple cases, a single variable is sufficient to identify an observation. \n\nThere are two types of keys:\n\n- A **primary key** uniquely identifies an observation in its own table. \n- A **foreign key** uniquely identifies an observation in another table. \n\n\n# Mutating joins\n\nThe `dplyr` package provides a set of functions for joining two data frames into a single data frame based on a set of key columns. There are several functions in the `*_join()` family. These functions all merge together two data frames; they differ in how they handle observations that exist in one but not both data frames. Here, are the four functions from this family that you will likely use the most often: \n\n\n::: {.cell layout-align=\"center\" preview='true'}\n::: {.cell-output-display}\n|Function       |What it includes in merged data frame                                                                     |\n|:--------------|:---------------------------------------------------------------------------------------------------------|\n|`left_join()`  |Includes all observations in the left data frame, whether or not there is a match in the right data frame |\n|`right_join()` |Includes all observations in the right data frame, whether or not there is a match in the left data frame |\n|`inner_join()` |Includes only observations that are in both data frames                                                   |\n|`full_join()`  |Includes all observations from both data frames                                                           |\n:::\n:::\n\n\n\n### The first table \n\nImagine you are conduct a study and collecting data on subjects and a health outcome. Often, subjects will make multiple visits (a so-called longitudinal study) and so we will record the outcome for each visit. Similarly, we may record other information about them, such as the kind of housing they live in.\n\nThis code creates a simple table with some made up data about some hypothetical subjects' outcomes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\noutcomes <- tibble(\n        id = rep(c(\"a\", \"b\", \"c\"), each = 3),\n        visit = rep(0:2, 3),\n        outcome = rnorm(3 * 3, 3)\n)\n\nprint(outcomes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 3\n  id    visit outcome\n  <chr> <int>   <dbl>\n1 a         0    3.78\n2 a         1    1.85\n3 a         2    4.35\n4 b         0    2.42\n5 b         1    1.10\n6 b         2    3.52\n7 c         0    3.78\n8 c         1    2.33\n9 c         2    3.58\n```\n:::\n:::\n\n\nNote that subjects are labeled by their id in the `id` column.\n\n\n\n### A second table\n\nHere is some code to create a second table (we will be joining the first and second tables shortly). This table contains some data about the hypothetical subjects' housing situation by recording the type of house they live in.\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nsubjects <- tibble(\n        id = c(\"a\", \"b\", \"c\"),\n        house = c(\"detached\", \"rowhouse\", \"rowhouse\")\n)\n\nprint(subjects)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  id    house   \n  <chr> <chr>   \n1 a     detached\n2 b     rowhouse\n3 c     rowhouse\n```\n:::\n:::\n\n\n\n### Left Join\n\nNow suppose we want to create a table that combines the information about houses with the information about the outcomes. We can use the `left_join()` function to merge the `outcomes` and `subjects` tables and produce the output above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(x = outcomes, y = subjects, by = \"id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 4\n  id    visit outcome house   \n  <chr> <int>   <dbl> <chr>   \n1 a         0    3.78 detached\n2 a         1    1.85 detached\n3 a         2    4.35 detached\n4 b         0    2.42 rowhouse\n5 b         1    1.10 rowhouse\n6 b         2    3.52 rowhouse\n7 c         0    3.78 rowhouse\n8 c         1    2.33 rowhouse\n9 c         2    3.58 rowhouse\n```\n:::\n:::\n\n\nThe `by` argument indicates the column (or columns) that the two tables have in common.\n\n\n\n### Left Join with Incomplete Data\n\nIn the previous examples, the `subjects` table didn't have a `visit` column. But suppose it did? Maybe people move around during the study. We could image a table like this one.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubjects <- tibble(\n        id = c(\"a\", \"b\", \"c\"),\n        visit = c(0, 1, 0),\n        house = c(\"detached\", \"rowhouse\", \"rowhouse\"),\n)\n\nprint(subjects)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  id    visit house   \n  <chr> <dbl> <chr>   \n1 a         0 detached\n2 b         1 rowhouse\n3 c         0 rowhouse\n```\n:::\n:::\n\n\nWhen we left joint the tables now we get:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(outcomes, subjects, by = c(\"id\", \"visit\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 4\n  id    visit outcome house   \n  <chr> <dbl>   <dbl> <chr>   \n1 a         0    3.78 detached\n2 a         1    1.85 <NA>    \n3 a         2    4.35 <NA>    \n4 b         0    2.42 <NA>    \n5 b         1    1.10 rowhouse\n6 b         2    3.52 <NA>    \n7 c         0    3.78 rowhouse\n8 c         1    2.33 <NA>    \n9 c         2    3.58 <NA>    \n```\n:::\n:::\n\n\nNotice how now if we do not have information about a subject's housing in a given visit, the `left_join()` function automatically inserts an `NA` value to indicate that it is missing.\n\nAlso, in the above example, we joined on the `id` and the `visit` columns.\n\nWe may even have a situation where we are missing housing data for a subject completely. The following table has no information about subject `a`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubjects <- tibble(\n        id = c(\"b\", \"c\"),\n        visit = c(1, 0),\n        house = c(\"rowhouse\", \"rowhouse\"),\n)\n\nsubjects\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  id    visit house   \n  <chr> <dbl> <chr>   \n1 b         1 rowhouse\n2 c         0 rowhouse\n```\n:::\n:::\n\n\n\nBut we can still join the tables together and the `house` values for subject `a` will all be `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(x = outcomes, y = subjects, by = c(\"id\", \"visit\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 4\n  id    visit outcome house   \n  <chr> <dbl>   <dbl> <chr>   \n1 a         0    3.78 <NA>    \n2 a         1    1.85 <NA>    \n3 a         2    4.35 <NA>    \n4 b         0    2.42 <NA>    \n5 b         1    1.10 rowhouse\n6 b         2    3.52 <NA>    \n7 c         0    3.78 rowhouse\n8 c         1    2.33 <NA>    \n9 c         2    3.58 <NA>    \n```\n:::\n:::\n\n\nThe bottom line for `left_join()` is that it always retains the values in the \"left\" argument (in this case the `outcomes` table). If there are no corresponding values in the \"right\" argument, `NA` values will be filled in.\n\n\n### Inner Join\n\n\nThe `inner_join()` function only retains the rows of both tables that have corresponding values. Here we can see the difference.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninner_join(x = outcomes, y = subjects, by = c(\"id\", \"visit\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n  id    visit outcome house   \n  <chr> <dbl>   <dbl> <chr>   \n1 b         1    1.10 rowhouse\n2 c         0    3.78 rowhouse\n```\n:::\n:::\n\n\n\n\n### Right Join\n\nThe `right_join()` function is like the `left_join()` function except that it gives priority to the \"right\" hand argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nright_join(x = outcomes, y = subjects, by = c(\"id\", \"visit\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n  id    visit outcome house   \n  <chr> <dbl>   <dbl> <chr>   \n1 b         1    1.10 rowhouse\n2 c         0    3.78 rowhouse\n```\n:::\n:::\n\n\n\n# Summary\n\n* `left_join()` is useful for merging a \"large\" data frame with a \"smaller\" one while retaining all the rows of the \"large\" data frame\n\n* `inner_join()` gives you the intersection of the rows between two data frames \n\n* `right_join()` is like `left_join()` with the arguments reversed (likely only useful at the end of a pipeline)\n\n\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1. If you had three data frames to combine with a shared key, how would you join them using the verbs you now know?\n\n2. Using `df1` and `df2` below, what is the difference between `inner_join(df1, df2)`, `semi_join(df1, df2)` and `anti_join(df1, df2)`? \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create first example data frame\ndf1 <- data.frame(ID = 1:3,\n                  X1 = c(\"a1\", \"a2\", \"a3\"))\n# Create second example data frame\ndf2 <- data.frame(ID = 2:4, \n                  X2 = c(\"b1\", \"b2\", \"b3\"))\n```\n:::\n\n\n3. Try changing the order from the above e.g. `inner_join(df2, df1)`, `semi_join(df2, df1)` and `anti_join(df2, df1)`. What changed? What did not change? \n\n:::\n\n### Additional Resources\n\n::: callout-tip\n\n- <https://rdpeng.github.io/Biostat776/lecture-joining-data-in-r-basics.html>\n- <https://r4ds.had.co.nz/relational-data.html>\n- <https://rafalab.github.io/dsbook/joining-tables.html>\n\n:::\n\n## rtistry\n\n\n::: {.cell .fig-cap-location-top}\n\n:::\n\n\n\\[Add here.\\]\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}