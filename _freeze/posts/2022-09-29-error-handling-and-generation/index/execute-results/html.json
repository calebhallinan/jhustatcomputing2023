{
  "hash": "aceba549d4602165e548d130a70c6319",
  "result": {
    "markdown": "---\ntitle: \"Error Handling and Generation\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Implement exception handling routines in R functions\"\ndate: 2022-09-29\ncategories: [module 4, week 5, programming, debugging]\n---\n\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1. <https://adv-r.hadley.nz/debugging>\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n- <https://rdpeng.github.io/Biostat776/lecture-error-handling-and-generation>\n- <https://adv-r.hadley.nz/debugging>\n\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n- Create errors, warnings, and messages in R functions using the functions `stop`, `stopifnot`, `warning`, and `message`.\n- Understand the importance of providing useful error messaging to improve user experience with functions. However, these can also slow down code substantially.\n\n:::\n\n# Error Handling and Generation\n\n## What is an error?\n\nErrors most often occur when code is used in a way that it is not intended to\nbe used. For example adding two strings together produces the following error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"hello\" + \"world\"\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in \"hello\" + \"world\": non-numeric argument to binary operator\n```\n:::\n:::\n\n\nThe `+` operator is essentially a function that takes two numbers as arguments\nand finds their sum. Since neither `\"hello\"` nor `\"world\"` are numbers, the\nR interpreter produces an error. Errors will stop the execution of your program,\nand they will (hopefully) print an error message to the R console.\n\nIn R there are two other constructs which are related to errors:\nwarnings and messages. Warnings are meant to indicate that something seems to\nhave gone wrong in your program that should be inspected. Here's a simple\nexample of a warning being generated:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(c(\"5\", \"6\", \"seven\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  5  6 NA\n```\n:::\n:::\n\n\nThe `as.numeric()` function attempts to convert each string in \n`c(\"5\", \"6\", \"seven\")` into a number, however it is impossible to convert\n`\"seven\"`, so a warning is generated. Execution of the code is not halted,\nand an `NA` is produced for `\"seven\"` instead of a number.\n\nMessages simply print to the R console, though they are generated by an\nunderlying mechanism that is similar to how errors and warning are generated.\nHere's a small function that will generate a message:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(){\n  message(\"This is a message.\")\n}\n\nf()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nThis is a message.\n```\n:::\n:::\n\n\n## Generating Errors\n\nThere are a few essential functions for generating errors, warnings, and\nmessages in R. The `stop()` function will generate an error. Let's generate\nan error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstop(\"Something erroneous has occurred!\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nError: Something erroneous has occurred!\n```\n:::\n\n\nIf an error occurs inside of a function then the name of that function will\nappear in the error message:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname_of_function <- function(){\n  stop(\"Something bad happened.\")\n}\n\nname_of_function()\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in name_of_function(): Something bad happened.\n```\n:::\n:::\n\n\nThe `stopifnot()` function takes a series of logical expressions as arguments\nand if any of them are false an error is generated specifying which expression\nis false. Let's take a look at an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nerror_if_n_is_greater_than_zero <- function(n){\n  stopifnot(n <= 0)\n  n\n}\n\nerror_if_n_is_greater_than_zero(5)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in error_if_n_is_greater_than_zero(5): n <= 0 is not TRUE\n```\n:::\n:::\n\n\nThe `warning()` function creates a warning, and the function itself is very\nsimilar to the `stop()` function. Remember that a warning does not stop the\nexecution of a program (unlike an error.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwarning(\"Consider yourself warned!\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Consider yourself warned!\n```\n:::\n:::\n\n\nJust like errors, a warning generated inside of a function will include the name\nof the function in which it was generated:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_NA <- function(x){\n  warning(\"Generating an NA.\")\n  NA\n}\n\nmake_NA(\"Sodium\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in make_NA(\"Sodium\"): Generating an NA.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nMessages are simpler than errors or warnings; they just print strings to the\nR console. You can issue a message with the `message()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmessage(\"In a bottle.\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nIn a bottle.\n```\n:::\n:::\n\n\n## When to generate errors or warnings\n\nStopping the execution of your program with `stop()` should only happen in the\nevent of a catastrophe - meaning only if it is impossible for your program to\ncontinue. If there are conditions that you can anticipate that would cause\nyour program to create an error, then you should document those conditions so\nwhoever uses your software is aware. An example includes: \n\n- Providing invalid arguments to a function. You could check this at the beginning of your\nprogram using `stopifnot()` so that the user can quickly realize something has gone wrong.\n\nYou can think of a function as kind of contract between you and the user: \n\n- if the user provides specified arguments, your program will provide predictable\nresults. Of course it's impossible for you to anticipate all of the potential\nuses of your program. It's appropriate to create\na warning when this contract between you and the user is violated. \n\nA perfect example of this situation is the result of \n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(c(\"5\", \"6\", \"seven\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  5  6 NA\n```\n:::\n:::\n\n\nThe user expects a vector of numbers to be returned as the\nresult of `as.numeric()` but `\"seven\"` is coerced into being NA, which is not\ncompletely intuitive.\n\nR has largely been developed according to the\n[Unix Philosophy](https://en.wikipedia.org/wiki/Unix_philosophy), which generally\n**discourages** printing text to the console unless something unexpected has\noccurred. Languages that commonly run on Unix systems like C and C++ are\nrarely used interactively, meaning that they usually underpin computer\ninfrastructure (computers \"talking\" to other computers). Messages printed to the\nconsole are therefore not very useful since nobody will ever read them and it's\nnot straightforward for other programs to capture and interpret them.\n\nIn contrast, R code is frequently executed by human beings in the R console, which\nserves as an interactive environment between the computer and person at the \nkeyboard. If you think your program should produce a message, make sure that\nthe output of the message is primarily meant for a human to read. You should avoid\nsignaling a condition or the result of your program to another program by\ncreating a message.\n\n## How should errors be handled?\n\nImagine writing a program that will take a long time to complete because of a\ncomplex calculation or because you're handling a large amount of data. If an\nerror occurs during this computation then you're liable to lose all of the\nresults that were calculated before the error, or your program may not finish a\ncritical task that a program further down your pipeline is depending on. If you\nanticipate the possibility of errors occurring during the execution of your\nprogram, then you can design your program to handle them appropriately.\n\nThe `tryCatch()` function is the workhorse of handling errors and warnings in R.\nThe first argument of this function is any R expression, followed by conditions\nwhich specify how to handle an error or a warning. The last argument, `finally`,\nspecifies a function or expression that will be executed after the expression\nno matter what, even in the event of an error or a warning.\n\nLet's construct a simple function I'm going to call \n[`beera`](https://en.wikipedia.org/wiki/Yogi_Berra) that catches errors and\nwarnings gracefully.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbeera <- function(expr){\n  tryCatch(expr,\n         error = function(e){\n           message(\"An error occurred:\\n\", e)\n         },\n         warning = function(w){\n           message(\"A warning occured:\\n\", w)\n         },\n         finally = {\n           message(\"Finally done!\")\n         })\n}\n```\n:::\n\n\nThis function takes an expression as an argument and tries to evaluate it. If\nthe expression can be evaluated without any errors or warnings then the result\nof the expression is returned and the message `Finally done!` is printed to the\nR console. If an error or warning is generated, then the functions that are\nprovided to the `error` or `warning` arguments are printed. Let's try this\nfunction out with a few examples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbeera({\n  2 + 2\n})\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nFinally done!\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nbeera({\n  \"two\" + 2\n})\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nAn error occurred:\nError in \"two\" + 2: non-numeric argument to binary operator\n\nFinally done!\n```\n:::\n\n```{.r .cell-code}\nbeera({\n  as.numeric(c(1, \"two\", 3))\n})\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nA warning occured:\nsimpleWarning in doTryCatch(return(expr), name, parentenv, handler): NAs introduced by coercion\n\nFinally done!\n```\n:::\n:::\n\n\nNotice that we've effectively transformed errors and warnings into messages.\n\nNow that you know the basics of generating and catching errors you'll need to\ndecide when your program should generate an error. My advice to you is to limit\nthe number of errors your program generates as much as possible. Even if you\ndesign your program so that it's able to catch and handle errors, the error\nhandling process slows down your program by orders of magnitude. Imagine you\nwanted to write a simple function that checks if an argument is an even number.\nYou might write the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_even <- function(n){\n  n %% 2 == 0\n}\n\nis_even(768)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis_even(\"two\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in n%%2: non-numeric argument to binary operator\n```\n:::\n:::\n\n\nYou can see that providing a string causes this function to raise an error. You\ncould imagine though that you want to use this function across a list of\ndifferent data types, and you only want to know which elements of that list are\neven numbers. You might think to write the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_even_error <- function(n){\n  tryCatch(n %% 2 == 0,\n           error = function(e){\n             FALSE\n           })\n}\n\nis_even_error(714)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis_even_error(\"eight\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nThis appears to be working the way you intended, however when applied to more\ndata this function will be seriously slow compared to alternatives. For example\nI could check that `n` is numeric before treating `n` like a number:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_even_check <- function(n){\n  is.numeric(n) && n %% 2 == 0\n}\n\nis_even_check(1876)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis_even_check(\"twelve\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n:::keyideas \n\nNotice that by using `is.numeric()` before the \"AND\" operator (`&&`), the\nexpression `n %% 2 == 0` is never evaluated. This is a programming language\ndesign feature called \"short circuiting.\" The expression can never evaluate to\n`TRUE` if the left hand side of `&&` evaluates to `FALSE`, so the right hand\nside is ignored.\n\n:::\n\nTo demonstrate the difference in the speed of the code, we will use the\n`microbenchmark` package to measure how long it takes for each function to be\napplied to the same data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(microbenchmark)\nmicrobenchmark(sapply(letters, is_even_check))\n```\n:::\n\n\n```\nUnit: microseconds\n                           expr    min      lq     mean  median      uq     max neval\n sapply(letters, is_even_check) 46.224 47.7975 61.43616 48.6445 58.4755 167.091   100\n```\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(sapply(letters, is_even_error))\n```\n:::\n\n\n```\nUnit: microseconds\n                           expr     min       lq     mean   median       uq      max neval\n sapply(letters, is_even_error) 640.067 678.0285 906.3037 784.4315 1044.501 2308.931   100\n```\n\nThe error catching approach is nearly 15 times slower!\n\nProper error handling is an essential tool for any software developer so that\nyou can design programs that are error tolerant. Creating clear and informative\nerror messages is essential for building quality software. \n\n:::{.callout-tip}\n\n### Pro-tip\n\nOne closing tip I\nrecommend is to put documentation for your software online, including the\nmeaning of the errors that your software can potentially throw. Often a user's\nfirst instinct when encountering an error is to search online for that error\nmessage, which should lead them to your documentation!\n\n:::\n\n# Summary \n\n- Errors, warnings, and messages can be generated within R code using the functions `stop`, `stopifnot`, `warning`, and `message`.\n\n- Catching errors, and providing useful error messaging, can improve user experience with functions but can also slow down code substantially.\n\n\n\n\n# Post-lecture materials\n\n### Additional Resources\n\n::: callout-tip\n\n- <https://rdpeng.github.io/Biostat776/lecture-error-handling-and-generation>\n- <https://adv-r.hadley.nz/debugging>\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}