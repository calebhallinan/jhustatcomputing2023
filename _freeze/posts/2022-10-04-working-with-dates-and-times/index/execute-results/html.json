{
  "hash": "873db4c3ddf4d3f8440920c8fdc25986",
  "result": {
    "markdown": "---\ntitle: \"Working with dates and times\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to lubridate for dates and times in R\"\ndate: 2022-10-04\ncategories: [module 5, week 6, tidyverse, R, programming, dates and times]\n---\n\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1. <https://r4ds.had.co.nz/dates-and-times>\n\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n- <https://jhu-advdatasci.github.io/2018/lectures/09-dates-times>\n- <https://r4ds.had.co.nz/dates-and-times>\n\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n- Recognize the `Date`, `POSIXct` and `POSIXlt` class types in R to represent dates and times\n- Learn how to create date and time objects in R using functions from the `lubridate` package\n- Learn how dealing with time zones can be frustrating 🙀 but hopefully less so after today's lecture 😺 \n- Learn how to perform arithmetic operations on dates and times \n- Learn how plotting systems in R \"know\" about dates and times to appropriately handle axis labels \n\n:::\n\n# Introduction\n\nIn this lesson, we will learn how to work with dates and times in R. \nThese may seem simple as you use them all of the time in your day-to-day life, \nbut the more you work with them, the more complicated they seem to get. \n\nDates and times are hard because they have to reconcile two physical phenomena (the rotation of the Earth and its orbit around the sun) with a whole raft of geopolitical phenomena including months, time zones, and daylight savings time (DST). \n\nThis lesson will not teach you every last detail about dates and times, but it will give you a solid grounding of practical skills that will help you with common data analysis challenges.\n\nR has developed a special representation of dates and times\n\n- Dates are represented by the `Date` class\n\n- Times are represented by the `POSIXct` or the `POSIXlt` class\n\n- Dates are stored internally as the number of days since 1970-01-01\n\n- Times are stored internally as the number of seconds since\n  1970-01-01\n\n## The `lubridate` package\n\nHere, we will focus on the `lubridate` R package, which makes it easier to work with dates and times in R. \n\n**check out the cheat sheet** at https://lubridate.tidyverse.org\n\nA few things to note about it: \n\n- It largely replaces the default date/time functions in base R\n\n- It contains methods for date/time arithmetic\n\n- It handles time zones, leap year, leap seconds, etc.\n\n`lubridate` is installed when you install `tidyverse`, but it is not loaded when you load `tidyverse`.\nAlternatively, you can install it separately. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"lubridate\") \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(lubridate) \n```\n:::\n\n\n\n# Creating date/times\n\nThere are three types of date/time data that refer to an instant in time:\n\n- A **date**. Tibbles print this as `<date>`.\n\n- A **time** within a day. Tibbles print this as `<time>`.\n\n- A **date-time** is a date plus a time: it uniquely identifies an instant in time (typically to the nearest second). Tibbles print this as `<dttm>`. Elsewhere in R these are called `POSIXct`. \n\nIn this lesson, we will focus on dates and date-times as R does not have a native class for storing times. If you need one, you can use the [`hms` package](https://cran.r-project.org/web/packages/hms/index.html).\n\nYou should always use the simplest possible data type that works for your needs. That means if you can use a date instead of a date-time, you should. Date-times are substantially more complicated because of the need to handle time zones, which we’ll come back to at the end of the lesson.\n\nTo get the current date or date-time you can use `today()` or `now()` from `lubridate`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-09-27\"\n```\n:::\n\n```{.r .cell-code}\nnow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-09-27 22:06:33 EDT\"\n```\n:::\n:::\n\n\nOtherwise, there are three ways you are likely to create a date/time:\n\n- From a string.\n- From individual date-time components.\n- From an existing date/time object.\n\nThey work as follows.\n\n## From a string\n\nDates are of the `Date` class. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- today()\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Date\"\n```\n:::\n:::\n\n\nDates can be coerced from a character strings using some helper functions from `lubridate`. \nThey automatically work out the format once you specify the order of the component. \n\nTo use the helper functions, identify the order in which year, month, and day appear in your dates, then arrange \"y\", \"m\", and \"d\" in the same order. \n\nThat gives you the name of the `lubridate` function that will parse your date. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd(\"1970-01-01\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1970-01-01\"\n```\n:::\n\n```{.r .cell-code}\nymd(\"2017-01-31\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-01-31\"\n```\n:::\n\n```{.r .cell-code}\nmdy(\"January 31st, 2017\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-01-31\"\n```\n:::\n\n```{.r .cell-code}\ndmy(\"31-Jan-2017\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-01-31\"\n```\n:::\n:::\n\n\n\n:::{.callout-tip}\n\n### Pro-tip\n\n- When reading in data with `read_csv()`, you may need to read in as character first and then convert to date/time\n\n- `Date` objects have their own special `print()` methods that will always format as \"YYYY-MM-DD\"\n\n- These functions also take unquoted numbers. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd(20170131)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-01-31\"\n```\n:::\n:::\n\n\n:::\n\n### Alternate Formulations\n\nDifferent locales have different ways of formatting dates\n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd(\"2016-09-13\")  ## International standard\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-13\"\n```\n:::\n\n```{.r .cell-code}\nymd(\"2016/09/13\")  ## Just figure it out\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-13\"\n```\n:::\n\n```{.r .cell-code}\nmdy(\"09-13-2016\")  ## Mostly U.S.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-13\"\n```\n:::\n\n```{.r .cell-code}\ndmy(\"13-09-2016\")  ## Europe\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-13\"\n```\n:::\n:::\n\n\nAll of the above are valid and lead to the exact same object.\n\nEven if the individual dates are formatted differently, `ymd()` can usually figure it out.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"2016-04-05\", \n       \"2016/05/06\",\n       \"2016,10,4\")\nymd(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-04-05\" \"2016-05-06\" \"2016-10-04\"\n```\n:::\n:::\n\n\n## From individual date-time components\n\nSometimes the date components will come across multiple columns in a dataset. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nycflights13)\n\nflights %>% \n  select(year, month, day)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 336,776 × 3\n    year month   day\n   <int> <int> <int>\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# … with 336,766 more rows\n```\n:::\n:::\n\n\nTo create a date/time from this sort of input, use `make_date()` for dates, or `make_datetime()` for date-times:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>% \n  select(year, month, day) %>% \n  mutate(departure = make_date(year, month, day))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 336,776 × 4\n    year month   day departure \n   <int> <int> <int> <date>    \n 1  2013     1     1 2013-01-01\n 2  2013     1     1 2013-01-01\n 3  2013     1     1 2013-01-01\n 4  2013     1     1 2013-01-01\n 5  2013     1     1 2013-01-01\n 6  2013     1     1 2013-01-01\n 7  2013     1     1 2013-01-01\n 8  2013     1     1 2013-01-01\n 9  2013     1     1 2013-01-01\n10  2013     1     1 2013-01-01\n# … with 336,766 more rows\n```\n:::\n:::\n\n\n:::{.callout-note}\n\n### Questions\n\nThe `flights` also contains a `hour` and `minute` column. Use `make_datetime()` to create a date-time column called `departure`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# try it yourself\n```\n:::\n\n\n:::\n\n## From other types\n\nYou may want to switch between a date-time and a date. That is the job of `as_datetime()` and `as_date()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-09-27\"\n```\n:::\n\n```{.r .cell-code}\nas_datetime(today())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-09-27 UTC\"\n```\n:::\n\n```{.r .cell-code}\nnow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-09-27 22:06:34 EDT\"\n```\n:::\n\n```{.r .cell-code}\nas_date(now())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-09-27\"\n```\n:::\n:::\n\n\n# Date-Times in R\n\n## From a string\n\n`ymd()` and friends create dates. To create a `date-time` from a character string, add an underscore and one or more of \"h\", \"m\", and \"s\" to the name of the parsing function:\n\nTimes can be coerced from a character string with `ymd_hms()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd_hms(\"2017-01-31 20:11:59\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-01-31 20:11:59 UTC\"\n```\n:::\n\n```{.r .cell-code}\nmdy_hm(\"01/31/2017 08:01\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-01-31 08:01:00 UTC\"\n```\n:::\n:::\n\n\nYou can also force the creation of a date-time from a date by supplying a timezone:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd_hms(\"2016-09-13 14:00:00\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-13 14:00:00 UTC\"\n```\n:::\n\n```{.r .cell-code}\nymd_hms(\"2016-09-13 14:00:00\", tz = \"America/New_York\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-13 14:00:00 EDT\"\n```\n:::\n\n```{.r .cell-code}\nymd_hms(\"2016-09-13 14:00:00\", tz = \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-13 14:00:00 EDT\"\n```\n:::\n:::\n\n\n## `POSIXct` or the `POSIXlt` class\n\nLet's get into some hairy details about date-times. Date-times are represented using the `POSIXct` or the `POSIXlt` class in R. What are these things? \n\n### `POSIXct`\n\n`POSIXct` is just a very large integer under the hood. It is a useful class when you want to store times in something like a data frame. \n\nTechnically, the `POSIXct` class represents the number of **seconds** since 1 January 1970. (In case you were wondering, \"POSIXct\" stands for \"Portable Operating System Interface\", calendar time.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd_hm(\"1970-01-01 01:00\")\nclass(x) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"POSIXct\" \"POSIXt\" \n```\n:::\n\n```{.r .cell-code}\nunclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3600\nattr(,\"tzone\")\n[1] \"UTC\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$class\n[1] \"POSIXct\" \"POSIXt\" \n\n$tzone\n[1] \"UTC\"\n```\n:::\n:::\n\n\n\n### `POSIXlt`\n\n`POSIXlt` is a `list` underneath and it stores a bunch of other useful information like the day of the week, day of the year, month, day of the month\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- as.POSIXlt(x)\n\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nattributes(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"sec\"   \"min\"   \"hour\"  \"mday\"  \"mon\"   \"year\"  \"wday\"  \"yday\"  \"isdst\"\n\n$class\n[1] \"POSIXlt\" \"POSIXt\" \n\n$tzone\n[1] \"UTC\"\n```\n:::\n:::\n\n\n:::{.callout-tip}\n\n### Pro-tip\n\n`POSIXlt`s are **rare** inside the tidyverse. They do crop up in base R, because they are needed to extract specific components of a date, like the year or month. \n\nSince `lubridate` provides helpers for you to do this instead, you do not really need them imho. \n\n`POSIXct`'s are always easier to work with, so if you find you have a `POSIXlt`, you should always convert it to a regular data time `lubridate::as_datetime()`.\n\n:::\n\n# Time Zones!\n\nTime zones were created to make your data analyses more difficult as a data analyst.\nHere are a few fun things to think about: \n\n* `ymd_hms()` function will by default use Coordinated Universal Time (UTC) as the time zone. UTC is the primary time standard by which the world regulates clocks and time.\n\nYou can go to Wikipedia to find the [list of time zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)\n\n\n* Specifying `tz = \"\"` in one of the `ymd()` and friends functions will use the local time zone\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd_hm(\"1970-01-01 01:00\", tz = \"\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1970-01-01 01:00:00 EST\"\n```\n:::\n\n```{.r .cell-code}\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$class\n[1] \"POSIXct\" \"POSIXt\" \n\n$tzone\n[1] \"\"\n```\n:::\n:::\n\n\n:::{.callout-tip}\n\n### Pro-tip\n\nThe `tzone` attribute is optional. It controls how the time is printed, not what absolute time it refers to.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(x, \"tzone\") <- \"US/Pacific\"\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1969-12-31 22:00:00 PST\"\n```\n:::\n\n```{.r .cell-code}\nattr(x, \"tzone\") <- \"US/Eastern\"\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1970-01-01 01:00:00 EST\"\n```\n:::\n:::\n\n\n:::\n\n\nA few other fun things to think about related to time zones: \n\n* Almost always better to specify time zone when possible to avoid ambiguity\n\n* Daylight savings time (DST)\n\n* Some states are in two time zones\n\n* Southern hemisphere is opposite\n\n\n# Operations on Dates and Times\n\n## Arithmetic \n\nYou can add and subtract dates and times. You can do comparisons too (i.e. `==`, `<=`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd(\"2012-01-01\", tz = \"\")  ## Midnight\ny <- dmy_hms(\"9 Jan 2011 11:34:21\", tz = \"\")\nx - y ## this works\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 356.5178 days\n```\n:::\n\n```{.r .cell-code}\nx < y ## this works\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nx > y ## this works\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nx == y ## this works\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nx + y ## what??? why does this not work? \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `+.POSIXt`(x, y): binary '+' is not defined for \"POSIXt\" objects\n```\n:::\n:::\n\n\n:::{.callout-tip}\n\n### Note\n\n`POSIXct` objects are a measure of seconds from an origin, usually the UNIX epoch (1st Jan 1970). \n\nJust add the requisite number of seconds to the object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx + 3*60*60 # add 3 hours\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2012-01-01 03:00:00 EST\"\n```\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2012-01-01 EST\"\n```\n:::\n:::\n\n\n:::\n\nSame goes for days. For example, you can just keep the date portion using `date()`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- date(y)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2011-01-09\"\n```\n:::\n:::\n\n\nAnd then add a number to the date (in this case 1 day)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny + 1  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2011-01-10\"\n```\n:::\n:::\n\n\nCool eh? \n\n\n## Leaps and Bounds\n\nEven keeps track of leap years, leap seconds, daylight savings, and time zones.\n\nLeap years\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd(\"2012-03-01\")\ny <- ymd(\"2012-02-28\")\nx - y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 2 days\n```\n:::\n:::\n\n\nNot a leap year \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd(\"2013-03-01\")\ny <- ymd(\"2013-02-28\")\nx - y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 1 days\n```\n:::\n:::\n\n\nBUT beware of time zones!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd_hms(\"2012-10-25 01:00:00\", tz = \"\")\ny <- ymd_hms(\"2012-10-25 05:00:00\", tz = \"GMT\")\ny - x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 0 secs\n```\n:::\n:::\n\n\nThere are also things called [**leap seconds**](https://en.wikipedia.org/wiki/Leap_second).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.leap.seconds\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"1972-07-01 GMT\" \"1973-01-01 GMT\" \"1974-01-01 GMT\" \"1975-01-01 GMT\"\n [5] \"1976-01-01 GMT\" \"1977-01-01 GMT\" \"1978-01-01 GMT\" \"1979-01-01 GMT\"\n [9] \"1980-01-01 GMT\" \"1981-07-01 GMT\" \"1982-07-01 GMT\" \"1983-07-01 GMT\"\n[13] \"1985-07-01 GMT\" \"1988-01-01 GMT\" \"1990-01-01 GMT\" \"1991-01-01 GMT\"\n[17] \"1992-07-01 GMT\" \"1993-07-01 GMT\" \"1994-07-01 GMT\" \"1996-01-01 GMT\"\n[21] \"1997-07-01 GMT\" \"1999-01-01 GMT\" \"2006-01-01 GMT\" \"2009-01-01 GMT\"\n[25] \"2012-07-01 GMT\" \"2015-07-01 GMT\" \"2017-01-01 GMT\"\n```\n:::\n:::\n\n\n# Extracting Elements of Dates/Times\n\nThere are a set of helper functions in `lubridate` that can extract sub-elements of dates/times\n\n## Date Elements\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd_hms(c(\"2012-10-25 01:13:46\",\n               \"2015-04-23 15:11:23\"), tz = \"\")\nyear(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2012 2015\n```\n:::\n\n```{.r .cell-code}\nmonth(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10  4\n```\n:::\n\n```{.r .cell-code}\nday(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25 23\n```\n:::\n\n```{.r .cell-code}\nweekdays(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Thursday\" \"Thursday\"\n```\n:::\n:::\n\n\n## Time Elements\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd_hms(c(\"2012-10-25 01:13:46\",\n               \"2015-04-23 15:11:23\"), tz = \"\")\nminute(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13 11\n```\n:::\n\n```{.r .cell-code}\nsecond(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 46 23\n```\n:::\n\n```{.r .cell-code}\nhour(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 15\n```\n:::\n\n```{.r .cell-code}\nweek(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 43 17\n```\n:::\n:::\n\n\n\n\n# Visualizing Dates\n\n\n## Reading in the Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\nlibrary(readr)\nstorm <- read_csv(here(\"data\", \"storms_2004.csv.gz\"), progress = FALSE)\nstorm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 52,409 × 51\n   BEGIN…¹ BEGIN…² BEGIN…³ END_Y…⁴ END_DAY END_T…⁵ EPISO…⁶ EVENT…⁷ STATE STATE…⁸\n     <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <chr>   <dbl>\n 1  200412      29    1800  200412      30    1200 1182771 5430389 MONT…      30\n 2  200412      29    1800  200412      30    1200 1182771 5430390 MONT…      30\n 3  200412       8    1800  200412       8    1800 1182769 5430387 IDAHO      16\n 4  200412      19    1500  200412      19    1700 1182770 5430388 MONT…      30\n 5  200412      14     600  200412      14     800 1182772 5430391 MONT…      30\n 6  200412      21     400  200412      21     800 1183013 5430322 MICH…      26\n 7  200412      21     400  200412      21     800 1183013 5430323 MICH…      26\n 8  200412      26    1500  200412      27     800 1182925 5430420 MASS…      25\n 9  200412      26    1500  200412      27     800 1182925 5430421 MASS…      25\n10  200412      11     800  200412      11    1300 1182849 5430278 DELA…      10\n# … with 52,399 more rows, 41 more variables: YEAR <dbl>, MONTH_NAME <chr>,\n#   EVENT_TYPE <chr>, CZ_TYPE <chr>, CZ_FIPS <dbl>, CZ_NAME <chr>, WFO <chr>,\n#   BEGIN_DATE_TIME <chr>, CZ_TIMEZONE <chr>, END_DATE_TIME <chr>,\n#   INJURIES_DIRECT <dbl>, INJURIES_INDIRECT <dbl>, DEATHS_DIRECT <dbl>,\n#   DEATHS_INDIRECT <dbl>, DAMAGE_PROPERTY <chr>, DAMAGE_CROPS <chr>,\n#   SOURCE <chr>, MAGNITUDE <dbl>, MAGNITUDE_TYPE <chr>, FLOOD_CAUSE <lgl>,\n#   CATEGORY <lgl>, TOR_F_SCALE <chr>, TOR_LENGTH <dbl>, TOR_WIDTH <dbl>, …\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(storm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"BEGIN_YEARMONTH\"    \"BEGIN_DAY\"          \"BEGIN_TIME\"        \n [4] \"END_YEARMONTH\"      \"END_DAY\"            \"END_TIME\"          \n [7] \"EPISODE_ID\"         \"EVENT_ID\"           \"STATE\"             \n[10] \"STATE_FIPS\"         \"YEAR\"               \"MONTH_NAME\"        \n[13] \"EVENT_TYPE\"         \"CZ_TYPE\"            \"CZ_FIPS\"           \n[16] \"CZ_NAME\"            \"WFO\"                \"BEGIN_DATE_TIME\"   \n[19] \"CZ_TIMEZONE\"        \"END_DATE_TIME\"      \"INJURIES_DIRECT\"   \n[22] \"INJURIES_INDIRECT\"  \"DEATHS_DIRECT\"      \"DEATHS_INDIRECT\"   \n[25] \"DAMAGE_PROPERTY\"    \"DAMAGE_CROPS\"       \"SOURCE\"            \n[28] \"MAGNITUDE\"          \"MAGNITUDE_TYPE\"     \"FLOOD_CAUSE\"       \n[31] \"CATEGORY\"           \"TOR_F_SCALE\"        \"TOR_LENGTH\"        \n[34] \"TOR_WIDTH\"          \"TOR_OTHER_WFO\"      \"TOR_OTHER_CZ_STATE\"\n[37] \"TOR_OTHER_CZ_FIPS\"  \"TOR_OTHER_CZ_NAME\"  \"BEGIN_RANGE\"       \n[40] \"BEGIN_AZIMUTH\"      \"BEGIN_LOCATION\"     \"END_RANGE\"         \n[43] \"END_AZIMUTH\"        \"END_LOCATION\"       \"BEGIN_LAT\"         \n[46] \"BEGIN_LON\"          \"END_LAT\"            \"END_LON\"           \n[49] \"EPISODE_NARRATIVE\"  \"EVENT_NARRATIVE\"    \"DATA_SOURCE\"       \n```\n:::\n:::\n\n\n\n:::{.callout-note}\n\n### Questions\n\nLet's take a look at the `BEGIN_DATE_TIME`, `EVENT_TYPE`, and `DEATHS_DIRECT` variables. \nTry to convert the `BEGIN_DATE_TIME` date/time column to a date/time R object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nstorm %>% \n  select(BEGIN_DATE_TIME, EVENT_TYPE, DEATHS_DIRECT) %>% \n  mutate(date = dmy_hms(BEGIN_DATE_TIME))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 52,409 × 4\n   BEGIN_DATE_TIME    EVENT_TYPE       DEATHS_DIRECT date               \n   <chr>              <chr>                    <dbl> <dttm>             \n 1 29-DEC-04 18:00:00 Heavy Snow                   0 2004-12-29 18:00:00\n 2 29-DEC-04 18:00:00 Heavy Snow                   0 2004-12-29 18:00:00\n 3 08-DEC-04 18:00:00 Winter Storm                 0 2004-12-08 18:00:00\n 4 19-DEC-04 15:00:00 High Wind                    0 2004-12-19 15:00:00\n 5 14-DEC-04 06:00:00 Winter Weather               0 2004-12-14 06:00:00\n 6 21-DEC-04 04:00:00 Winter Storm                 0 2004-12-21 04:00:00\n 7 21-DEC-04 04:00:00 Winter Storm                 0 2004-12-21 04:00:00\n 8 26-DEC-04 15:00:00 Winter Storm                 0 2004-12-26 15:00:00\n 9 26-DEC-04 15:00:00 Winter Storm                 0 2004-12-26 15:00:00\n10 11-DEC-04 08:00:00 Storm Surge/Tide             0 2004-12-11 08:00:00\n# … with 52,399 more rows\n```\n:::\n\n```{.r .cell-code}\n# try it yourself\n```\n:::\n\n\n:::\n\nNext, we do some wrangling to create a `storm_sub` data frame (code chunk set to `echo=FALSE` for the purposes of the lecture, but code is in the R Markdown).\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstorm_sub\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 52,409 × 3\n   begin               type             deaths\n   <dttm>              <chr>             <dbl>\n 1 2004-12-29 18:00:00 Heavy Snow            0\n 2 2004-12-29 18:00:00 Heavy Snow            0\n 3 2004-12-08 18:00:00 Winter Storm          0\n 4 2004-12-19 15:00:00 High Wind             0\n 5 2004-12-14 06:00:00 Winter Weather        0\n 6 2004-12-21 04:00:00 Winter Storm          0\n 7 2004-12-21 04:00:00 Winter Storm          0\n 8 2004-12-26 15:00:00 Winter Storm          0\n 9 2004-12-26 15:00:00 Winter Storm          0\n10 2004-12-11 08:00:00 Storm Surge/Tide      0\n# … with 52,399 more rows\n```\n:::\n:::\n\n\n\n## Histograms of Dates/Times\n\n\nWe can make a histogram of the dates/times to get a sense of when storm events occur.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nstorm_sub %>%\n  ggplot(aes(x = begin)) + \n  geom_histogram(bins = 20) + \n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\nWe can group by event type too.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nstorm_sub %>%\n  ggplot(aes(x = begin)) + \n  facet_wrap(~ type) + \n  geom_histogram(bins = 20) + \n  theme_bw() + \n  theme(axis.text.x.bottom = element_text(angle = 90))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-35-1.png){width=1152}\n:::\n:::\n\n\n## Scatterplots of Dates/Times\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorm_sub %>%\n  ggplot(aes(x = begin, y = deaths)) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\nIf we focus on a single month, the x-axis adapts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorm_sub %>%\n  filter(month(begin) == 6) %>%\n  ggplot(aes(begin, deaths)) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n:::\n\n\nSimilarly, we can focus on a single day.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorm_sub %>%\n  filter(month(begin) == 6, day(begin) == 16) %>%\n  ggplot(aes(begin, deaths)) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n\n# Summary\n\n- Dates and times have special classes in R that allow for numerical and statistical calculations\n\n- Dates use the `Date` class\n\n- Date-Times (and Times) use the `POSIXct` and `POSIXlt` class\n\n- Character strings can be coerced to Date/Time classes using the `ymd()` and `ymd_hms()` functions and friends. \n\n- The `lubridate` package is essential for manipulating date/time data\n\n- Both `plot` and `ggplot` \"know\" about dates and times and will handle axis labels appropriately.\n\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n\n### Questions\n\n1. What happens if you parse a string that contains invalid dates?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd(c(\"2010-10-10\", \"bananas\"))\n```\n:::\n\n\n2. What does the `tzone` argument to `today()` do? Why is it important?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunclass(today())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19262\n```\n:::\n:::\n\n\n\n3. Use the appropriate `lubridate` function to parse each of the following dates:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- \"January 1, 2010\"\nd2 <- \"2015-Mar-07\"\nd3 <- \"06-Jun-2017\"\nd4 <- c(\"August 19 (2015)\", \"July 1 (2015)\")\nd5 <- \"12/30/14\" # Dec 30, 20\n```\n:::\n\n\n4. Using the `flights` dataset, how does the distribution of flight times within a day change over the course of the year?\n\n5. Compare `dep_time`, `sched_dep_time` and `dep_delay`. Are they consistent? Explain your findings.\n\n:::\n\n### Additional Resources\n\n::: callout-tip\n\n- <https://lubridate.tidyverse.org>\n- `lubridate` cheat sheet: <https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf>\n- <https://jhu-advdatasci.github.io/2018/lectures/09-dates-times>\n- <https://r4ds.had.co.nz/dates-and-times>\n\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}